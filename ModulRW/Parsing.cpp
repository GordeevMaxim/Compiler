#include "pch.h"
#include "Parsing.h"

extern FILE *file_program;
extern unsigned int *op_rel,
*st_express,
*begpart,
*st_typepart,
*st_varpart,
*st_procfuncpart,
*af_sameparam,
*st_all,
*blockfol,
*st_statpart,
*af_compstatement,
*idstarters,
*st_typ,
*m_scolon,
*af_headfunproc,
*af_blockprocfunc,
*rpar,
*m_fpar,
*st_statement,
*comp_stat,
*af_assignment,
*st_termfact,
*af_3const1,
*m_comma,
*op_mult,
*op_add,
*af_iftrue,
*af_for1,
*af_whilefor;

//-----------------------------------------БЛОК (НАЧАЛО)-------------------------------------------------------//

/* Анализ конструкции "блок" */
void Block(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, begpart))
	{
		Error(18, token); /* ошибка в разделе описаний */
		Skipto2(begpart, followers);
	}
	if (Belong(Symbol, begpart))
	{
		SetDisjunct(st_typepart,followers,ptra);
		ConstPart();//объявление констант

		SetDisjunct(st_varpart, followers, ptra);
		TypePart();//описание типов

		SetDisjunct(st_procfuncpart, followers, ptra);
		VarPart(ptra);//описание переменных
		ProcFuncPart(ptra);//описание процедур и функций
		BeginStatement(followers);//тело программы (или составной оператор)
		if (!Belong(Symbol, followers))
		{
			Error(6, token); /* заперещённый символ */
			Skipto1(followers);
		}
	}
}

//-----------------------------------------БЛОК (КОНЕЦ)--------------------------------------------------------//



//------------------------------------РАЗДЕЛ КОНСТАНТ(НАЧАЛО)---------------------------------------------------//

/* Анализ конструкции "раздел констант" */
void ConstPart()
{
	if (Symbol == constsy)
	{
		NextSym();
		do {
			One_Const();
			Accept(semicolonc);
		} while (Symbol == ident);
	}
}
/* Анализ конструкции "определение одной константы" */
void One_Const()
{
	Accept(ident);
	Accept(equalc);
	Constant();
}
/* Анализ конструкции "константа" (число, символ, слово ...) */
void Constant()
{
	switch (Symbol)
	{
	case integerc:
		Un_Int();
		break;
	case realc:
		Un_Real();
		break;
	case plusc:;
	case minusc:
		NextSym();
		Constant();
		break;
	case ident:
		NameConstant();
		break;
	}
}
/* Анализ конструкции "целое без знака" */
void Un_Int()
{
	Accept(integerc);
}
/* Анализ конструкции "вещественное без знака" */
void Un_Real()
{
	Accept(realc);
}
/* Анализ конструкции "имя константы" */
void NameConstant()
{
	Accept(ident);
}
//void String()
////Анализ конструкции "строка"
//{
//	Accept(stringc);
//}
//void Const_Char()
////Анализ конструкции "символ"
//{
//	Accept(charc);
//}

//------------------------------------РАЗДЕЛ КОНСТАНТ(КОНЕЦ)----------------------------------------------------//



//------------------------------------РАЗДЕЛ ТИПОВ(НАЧАЛО)------------------------------------------------------//

/* Анализ конструкции "раздел типов" */
void TypePart()
{
	if (Symbol == typesy)
	{
		NextSym();
		do {
			//One_Type();
			Accept(semicolonc);
		} while (Symbol == ident);
	}
}
/* Анализ конструкции "определение одного типа" */
void One_Type(unsigned *followers)
{
	Accept(ident);
	Accept(equalc);
	Type(followers);
}

//------------------ОПИСАНИЕ ТИПОВ ( ПЕРЕЧИСЛИМЫЙ, ОГРАНИЧЕННЫЙ,СТАНДАРТНЫЙ, СОСТАВНОЙ... )--------------------//

/* Анализ конструкции "тип" */
void Type(unsigned *followers)
{
	if (!Belong(Symbol, st_typ))
	{
		Error(18, token);
		Skipto2(st_typ, followers);
	}
	if (Belong(Symbol, st_typ))
	{
		if (Symbol == integerc || Symbol == plusc || Symbol == minusc || Symbol == charc || Symbol == leftparc || Symbol == ident)
			SimpleType(followers);//простой тип
		else
			if (Symbol == arraysy || Symbol == setsy || Symbol == filesy)
				CompoundType(followers);//составной тип
			else
				if (Symbol == arrowc)
					ReferenceType();//ссылочный тип
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "простой тип" */
void SimpleType(unsigned *followers)
{
	switch (Symbol)
	{
	case leftparc: PerechislType(); break;//перечислимый тип
	case ident: NameType();break;//стандартный тип  <<<для массива будет отслеживаться на этапе семантического Анализа>>>
	default://ограниченный тип
		if (Symbol == integerc || Symbol == plusc|| Symbol == minusc || Symbol == charc)
			LimitedType();
	}
}
/* Анализ конструкции перечислимый тип */
void PerechislType()
{
	NextSym();
	Accept(ident);
	while (Symbol ==commac)
	{
		NextSym();
		Accept(ident);
	}
	Accept(rightparc);
}
/* Анализ конструкции ограниченный тип */
void LimitedType()
{
	Constant();
	Accept(twopointsc);
	Constant();
}
/* стандартный тип или Анализ конструкции имя типа */
void NameType()
{
	Accept(ident);
	if (Symbol == twopointsc)
	{
		NextSym();
		Accept(ident);
	}
}
/* Анализ конструкции составной тип */
void CompoundType(unsigned *followers)
{
	switch (Symbol)
	{
	case arraysy: //массив
		ArrayType(followers);
		break;
	case setsy://множество
		NextSym();
		Accept(ofsy);
		BazisType(followers);
		break;
	case filesy://файловый тип
		NextSym();
		Accept(ofsy);
		Type(followers);
		break;
	}
}
/* Анализ конструкции тип элементов множества */
void BazisType(unsigned *followers)
{
	SimpleType(followers);
}
/* Анализ конструкции ссылочный тип */
void ReferenceType()
{
	NextSym();
	NameType();
}
/* Анализ конструкции "регулярный тип" или массив */
void ArrayType(unsigned *followers)
{
	Accept(arraysy);
	Accept(lbracketc);
	SimpleType(followers);
	while (Symbol ==commac)
	{
		NextSym();
		SimpleType(followers);
	}
	Accept(rbracketc);
	Accept(ofsy);
	Type(followers);
}

//--------------------------------------------РАЗДЕЛ ТИПОВ( КОНЕЦ )---------------------------------------------//



//------------------------------------------РАЗДЕЛ ПЕРЕМЕННЫХ(НАЧАЛО)-------------------------------------------//
/* Анализ конструкции "раздел переменных" */
void VarPart(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_varpart))
	{
		Error(18, token);
		Skipto2(st_varpart, followers);
	}
	if (Symbol == varsy)
	{
		SetDisjunct(af_sameparam, followers, ptra);
		Accept(varsy);
		do {
			VarDeclaration(ptra, followers);
			Accept(semicolonc);
		} while (Symbol == ident);
		if (!Belong(Symbol, followers))
		{
			Error(6, token); /* заперещённый символ */
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "описание однотипных переменных" */
void VarDeclaration(unsigned *followers, unsigned *fol)
{
	unsigned ptra[SET_SIZE], dop[SET_SIZE];
	int flag = 0;
	if (!Belong(Symbol, idstarters))
	{
		Error(2, token);
		Skipto2(idstarters, followers);
	}
	if (Symbol == ident) {
		NextSym();
		while (Symbol == commac)
		{			
			NextSym();
			if (Symbol == commac) flag = 1;
			Accept(ident);
			if (!Belong(Symbol, ptra) && Symbol != commac || flag)
			{
				Skipto2(ptra, fol);
				if (Symbol == ident) Accept(ident);
				flag = 0;
			}
		}
		Accept(colonc);
		Type(followers);
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}

//------------------------------------------РАЗДЕЛ ПЕРЕМЕННЫХ(КОНЕЦ)--------------------------------------------//

//---------------------------------------РАЗДЕЛ ПРОЦЕДУР И ФУНКЦИЙ(НАЧАЛО)--------------------------------------//

/* Анализ конструкции "раздел процедур и фукций" */
void ProcFuncPart(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_procfuncpart))
	{
		Error(18, token);
		Skipto2(st_procfuncpart, followers);
	}
	if (Symbol == functionsy || Symbol == proceduresy)
	{
		SetDisjunct(m_scolon, followers, ptra);
		while (Symbol == functionsy || Symbol == proceduresy)
		{
			DeclarationProcFun(ptra);
			Accept(semicolonc);
		}
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "описание процедуры или фукции" */
void DeclarationProcFun(unsigned *followers)
{
	switch (Symbol)
	{
	case proceduresy:
		DeclarationProc(followers);
		break;
	case functionsy:
		DeclarationFun(followers);
		break;
	}
	if (!Belong(Symbol, followers))
	{
		Error(6, token);
		Skipto1(followers);
	}
}
/* Анализ конструкции "описание процедуры" */
void DeclarationProc(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	SetDisjunct(blockfol, af_headfunproc, ptra);
	HeaderProc(ptra);
	Block(af_blockprocfunc);
}
/* Анализ конструкции "описание функции" */
void DeclarationFun(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	SetDisjunct(blockfol, af_headfunproc, ptra);
	HeaderFun(af_headfunproc);
	Block(ptra);
}
/* Анализ конструкции "заголовок процедуры" */
void HeaderProc(unsigned *followers)
{
	unsigned ptra[SET_SIZE], dop[SET_SIZE];
	Accept(proceduresy);
	if (!Belong(Symbol, idstarters))
	{
		Error(2, token);
		Skipto2(idstarters, followers);
	}
	if (Symbol == ident)
	{
		Accept(ident);
		if (Symbol == leftparc)
		{
			SetDisjunct(rpar, followers, ptra);
			SetDisjunct(af_sameparam, followers, dop);
			do
			{
				NextSym();
				FormalParameters(dop,ptra);
			} while (Symbol == semicolonc);
			Accept(rightparc);
			Accept(semicolonc);
		}
		else
			Accept(semicolonc);
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "заголовок функции" */
void HeaderFun(unsigned *followers)
{
	unsigned ptra[SET_SIZE], dop[SET_SIZE];
	Accept(functionsy);
	if (!Belong(Symbol, idstarters))
	{
		Error(2, token);
		Skipto2(idstarters, followers);
	}
	if (Symbol == ident)
	{
		Accept(ident);
		if (Symbol == leftparc)
		{
			SetDisjunct(rpar, followers, ptra);
			SetDisjunct(af_sameparam, followers, dop);
			do
			{
				NextSym();
				FormalParameters(dop, ptra);
			} while (Symbol == semicolonc);
			Accept(rightparc);
		}
		Accept(colonc);
		NameType();//NameType(dop);
		Accept(semicolonc);
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "раздел фомальных параметорв" */
void FormalParameters(unsigned *followers, unsigned *fol)
{
	if (!Belong(Symbol, m_fpar))
	{
		Error(20, token);//не знаю как описать
		Skipto2(m_fpar, followers);
	}
	if (Belong(Symbol, m_fpar))
	{
		switch (Symbol)
		{
		case ident:
			VarDeclaration(followers, fol);
			break;
		case varsy:
			NextSym();
			VarDeclaration(followers, fol);
			break;
		case functionsy:
			NextSym();
			VarDeclaration(followers, fol);
			break;
		case proceduresy:
			NextSym();
			Accept(ident);
			while (Symbol == commac)
				Accept(ident);
			break;
		}
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
//---------------------------------------РАЗДЕЛ ПРОЦЕДУР И ФУНКЦИЙ(КОНЕЦ)---------------------------------------//

//--------------------------------------------ВЫРАЖЕНИЕ ( НАЧАЛО )----------------------------------------------//
/* Анализ конструкции "выражение" */
void Expression(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_express))
	{
		Error(23, token);
		Skipto2(st_express, followers);
	}
	if (Belong(Symbol, st_express))
	{
		SetDisjunct(op_rel, followers, ptra);
		SimpleExpression(ptra);
		if (Symbol == equalc || Symbol == laterc || Symbol == greaterc || Symbol == latergreaterc || Symbol == laterequalc || Symbol == greaterequalc)
		{
			NextSym();
			SimpleExpression(followers);
		}
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "простое выражение" */
void SimpleExpression(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_express))
	{
		Error(23, token);
		Skipto2(st_express, followers);
	}
	if (Belong(Symbol, st_express))
	{
		SetDisjunct(op_add, followers, ptra);
		if (Belong(Symbol, op_add))
			NextSym();
		Term(ptra);
		while (Symbol == plusc || Symbol == minusc || Symbol == orsy)
		{
			NextSym();
			Term(ptra);
		}
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "слагаемое" */
void Term(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_termfact))
	{
		Error(23, token);
		Skipto2(st_termfact, followers);
	}
	if (Belong(Symbol, st_termfact))
	{
		SetDisjunct(followers, st_express, ptra);//начальные символы выражения с конечными 
		//+операиции мультипликат
		SetDisjunct(ptra, op_mult, ptra);
		Factor(ptra);
		while (Belong(Symbol, op_mult))
		{
			NextSym();
			Factor(ptra);
		}
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции "множитель" */
void Factor(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_termfact))
	{
		Error(23, token);
		Skipto2(st_termfact, followers);
	}
	if (Belong(Symbol, st_termfact))
	{
		switch (Symbol)
		{
		case leftparc://если в скобках т.е составной множитель
			NextSym();
			SetDisjunct(followers, af_3const1, ptra);//af_3const1 = twopoints,comma,rbracket
			SetDisjunct(ptra, rpar, ptra);
			Expression(ptra);
			Accept(rightparc);
			break;
		case notsy:// отрицание перед всем множителем
			NextSym();
			Factor(followers);
			break;
		case ident://имя переменной или вызов функции
			Accept(ident);
			if (Symbol == leftparc)
			{
				SetDisjunct(followers, rpar, ptra);
				NextSym();
				NameFunc(ptra);
				Accept(rightparc);
			}
			break;
		case integerc://целое число
			Accept(integerc);
			break;
		case realc://вещественное число
			Accept(realc);
			break;
		}
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
/* Анализ конструкции фактические параметры функции ( и процедуры) */
void NameFunc(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_express))
	{
		Error(23, token);
		Skipto2(st_express, followers);
	}
	if (Belong(Symbol, st_express))
	{
		SetDisjunct(followers, m_comma, ptra);
		do {
			NextSym();
			Expression(ptra);
		} while (Symbol == commac);
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
//---------------------------------------ВЫРАЖЕНИЕ ( КОНЕЦ )----------------------------------------------------//



//-----------------------------------------ОПИСАНИЕ ОПЕРАТОРОВ (НАЧАЛО)-----------------------------------------//
/*Анализ конструкции "оператор"*/
void Statement(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_statement))
	{
		Error(24, token);
		Skipto2(st_statement, followers);
	}
	if (Belong(Symbol, st_statement))//intc,endsy,elsesy,untilsy,ident,beginsy,ifsy,
	//whilesy,repeatsy,forsy,casesy,withsy,semicolon,gotosy,eolint
	{
		SetDisjunct(followers, st_statement, ptra);
		
		switch (Symbol)
		{
		case whilesy:
			//Анализ конструкции "цикл с предусловием"
			SetDisjunct(ptra, af_whilefor, ptra);
			WhileStatement(ptra);
			break;
		case repeatsy:
			//Анализ конструкции "цикл с постусловием"
			RepeatStatement(ptra);
			break;
		case forsy:
			//Анализ конструкции "цикл с параметром"
			SetDisjunct(ptra, af_whilefor, ptra);
			SetDisjunct(ptra, af_for1, ptra);
			ForStatement(ptra);
			break;
		case ifsy:
			//Анализ конструкции "условный оператор"
			SetDisjunct(ptra, af_iftrue, ptra);
			IfStatement(ptra);
			break;
		case casesy:
			CaseStatement(ptra);
			break;
		case beginsy:
			BeginStatement(followers);
			break;
		case semicolonc:
			Accept(semicolonc);
			break;
		case ident:
			Accept(ident);
			if (Symbol == leftparc)
			{
				SetDisjunct(followers, rpar, ptra);
				CallProc(ptra);
				Accept(rightparc);
			}
			else
				if (Symbol == assignc)
					GivingStatement(followers);
			break;
		case endsy:		break;
		}
		if (!Belong(Symbol, followers))
		{
			Error(6, token);
			Skipto1(followers);
		}
	}
}
 /* Анализ конструкции "оператор присваивания" */ 
void AssignStatement(unsigned *followers)
{
	Accept(ident);
	Accept(assignc);
	Expression(followers);
}
/* Анализ конструкции "составной оператор" */
void BeginStatement(unsigned *followers)
 {
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_statpart))//st_statpart содержит beginsy
	{
		Error(17, token);
		Skipto2(st_statpart, followers);
	}
	if (Belong(Symbol, st_statpart))//st_statpart содержит beginsy
	{
		Accept(beginsy);
		SetDisjunct(followers, af_compstatement, ptra); //af_compstatement содержит semicolon, endsy
		do {
			if (Symbol == semicolonc) Accept(semicolonc);
			Statement(ptra);
		} while (Symbol == semicolonc);
		Accept(endsy);
	}
 }
/* Анализ конструкции "цикл с предусловием" */
void WhileStatement(unsigned *followers)
{	
	Accept(whilesy);
	Expression(followers);
	Accept(dosy);
	Statement(followers);
}
/* Анализ конструкции "условный оператор" */
void IfStatement(unsigned *followers)
{
	Accept(ifsy);
	Expression(followers);
	Accept(thensy);
	Statement(followers);
	if (Symbol == elsesy)
	{
		NextSym();
		Statement(followers);
	}
}
/* Анализ конструкции "оператор выбора " */
void CaseStatement(unsigned *followers)
{
	Accept(casesy);
	Expression(followers);
	Accept(ofsy);
	while (Symbol == semicolonc)
	{
		NextSym();
	}
	Accept(endsy);
}
/* Анализ конструкции "цикл с постусловием" */
void RepeatStatement(unsigned *followers)
{
	Accept(repeatsy);
	Statement(followers);
	while (Symbol == semicolonc)
	{
		NextSym();
		Statement(followers);
	}
	Accept(untilsy);
	Expression(followers);
}
/* Анализ конструкции "цикл с параметром" */
void ForStatement(unsigned *followers)
{
	Accept(forsy);
	Accept(ident);
	Accept(assignc);
	Expression(followers);
	if (Symbol == tosy || Symbol == downtosy)
		NextSym();
	Expression(followers);
	Accept(dosy);
	Statement(followers);
}
/* Инициализация анализа выражения */
void GivingStatement(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	SetDisjunct(af_assignment, followers, ptra);//af_assignment содержит assign
	Accept(assignc);
	SetDisjunct(followers, comp_stat, ptra);
	Expression(ptra);
	if (!Belong(Symbol, followers))
	{
		Error(6, token);
		Skipto1(followers);
	}
}
/*Инициализация анализа процедуры*/
void CallProc(unsigned *followers)
{
	NameFunc(followers);
}
//-----------------------------------------ОПИСАНИЕ ОПЕРАТОРОВ (КОНЕЦ)-----------------------------------------//


void Programme(unsigned *followers)
{
	unsigned ptra[SET_SIZE];
	if (!Belong(Symbol, st_all))  //st_all содержит programsy
	{
		Error(3, token); //ожидается слово PROGRAM
		Skipto2(st_all, followers);
	}
	if (Belong(Symbol, st_all))
	{
		Accept(programsy);
		Accept(ident);
		Accept(semicolonc);
		Block(blockfol);
		Accept(pointc);
		//while (!feof(file_program)) NextCh();
		//if (!Belong(Symbol, followers))
		//{
		//	Error(6, token);
		//	Skipto1(followers);
		//}
	}
}